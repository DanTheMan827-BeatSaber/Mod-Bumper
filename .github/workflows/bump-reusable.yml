name: Bump mods (Reusable)

on:
  workflow_call:
    inputs:
      id:
        required: true
        type: string
      game_version:
        required: true
        type: string
      bs_cordl:
        required: true
        type: string
      newest_mods:
        required: true
        type: string
      repo:
        required: true
        type: string
      version:
        required: false
        type: string
      branch:
        required: false
        type: string
      install:
        required: false
        type: boolean
        default: false
      force_build:
        required: false
        type: boolean
        default: false
      prebump_command:
        required: false
        type: string
      build_command:
        required: false
        type: string
      qmod_command:
        required: false
        type: string
      installed_mods:
        required: true
        type: string

permissions:
  actions: write

jobs:
  bump:
    runs-on: ubuntu-latest
    continue-on-error: true
    name: bump ${{ inputs.id }}
    defaults:
      run:
        working-directory: ${{ github.workspace }}/${{ inputs.id }}
    outputs:
      need-cached: ${{ steps.cached-deps.outputs.need-cached }}
      upload-cache: ${{ steps.cached-deps.outputs.upload-cache }}
      id: ${{ steps.qpm_id.outputs.id }}
      cache-name: ${{ steps.cache-name.outputs.cache-name }}

    env:
      run_build: true

    steps:
      - uses: actions/checkout@v4

      - name: Ensure working directory exists
        working-directory: ${{ github.workspace }}
        run: |
          mkdir -p "${{ github.workspace }}/${{ inputs.id }}"

      - name: Get game_version
        id: game_version
        run: |
          echo "Game version is ${{ inputs.game_version }}"

      - name: Configure ENV
        run: |
          echo "HOME=$HOME" | tee -a "$GITHUB_ENV"
          echo "CPM_SOURCE_CACHE=$HOME/.cpm-cache/" | tee -a "$GITHUB_ENV"
          echo "SCCACHE_DIR=$HOME/.cache/sccache/" | tee -a "$GITHUB_ENV"
          echo "RUSTC_WRAPPER=sccache" | tee -a "$GITHUB_ENV"
          echo "timestamp=$(date +%s)" | tee -a "$GITHUB_ENV"

      - name: Checkout repository
        run: |
          if [ -n "${{ inputs.branch }}" ]; then
            echo "Checking out branch ${{ inputs.branch }} of repository ${{ inputs.repo }}"
            git clone "${{ inputs.repo }}" --recursive --branch "${{ inputs.branch }}" .
          else
            echo "Checking out default branch of repository ${{ inputs.repo }}"
            git clone "${{ inputs.repo }}" --recursive .
          fi

          # Output the current commit hash
          echo "git_commit=$(git rev-parse HEAD)" >> $GITHUB_ENV

      - name: Get ID from qpm.json
        id: qpm_id
        run: |
          if [ -f qpm.json ]; then
            id="$(jq -r '.info.id' qpm.json)"
            echo "id=$id" >> $GITHUB_OUTPUT
          else
            echo "qpm.json not found!"
            exit 1
          fi
          
          cat $GITHUB_OUTPUT
      
      - name: Get cache name
        id: cache-name
        run: |
          PREFIX="cache_"
          echo "cache-name=${PREFIX}${{ steps.qpm_id.outputs.id }}" >> $GITHUB_OUTPUT
          echo "cache-prefix=$PREFIX" >> $GITHUB_OUTPUT
          cat $GITHUB_OUTPUT
      
      - name: Download qpm-* artifacts and restore them
        working-directory: ${{ github.workspace }}
        continue-on-error: true
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          source ".github/source-all"
          artifacts_temp="$(mktemp -d)"
          gh run download ${{ github.run_id }} -p '${{ steps.cache-name.outputs.cache-prefix }}*' -D "$artifacts_temp" || exit 0
          cd "$artifacts_temp"
          for mod in */*/*; do
            restore-qpm-cache "$mod" --mv || true
          done
          
          rm -rf "$artifacts_temp"
          
      - name: Setup qpm
        uses: fernthedev/qpm-action@v1
        with:
          workflow_token: ${{ github.token }}
          restore: false
          resolve_ndk: false
          cache: false

      - name: Setup qpm ndk path
        run: |
          NDK_PATH=/usr/local/lib/android/sdk/ndk
          sudo mkdir -p "$NDK_PATH"
          sudo chmod +rwx "$NDK_PATH"
          qpm config ndk-path "$NDK_PATH"

      - name: QPM cache clear
        run: |
          qpm cache clear "${{ steps.qpm_id.outputs.id }}" || echo "No cache to clear for ${{ steps.qpm_id.outputs.id }}"

      - name: List QPM cache
        run: |
          qpm cache list || echo "No cache to list"

      - name: Check for ${{ steps.qpm_id.outputs.id }} v${{ inputs.version || '0.0.0' }}
        run: |
          echo "run_build=true" >> $GITHUB_ENV

          if [[ "${{ inputs.force_build }}" == "true" ]]; then
            exit 0
          fi

          if [[ "${{ inputs.version }}" != '' ]]; then
            pkg_temp="$(mktemp -d)"
            (
              cd "$pkg_temp"
              qpm package create "package-test" "0.1.0"
              qpm dependency add bs-cordl -v "${{ inputs.bs_cordl }}"
              qpm dependency add "${{ steps.qpm_id.outputs.id }}" -v "^${{ inputs.version }}"
              if qpm restore --update; then
                echo "run_build=false" >> $GITHUB_ENV
              else
                echo "Package ${{ steps.qpm_id.outputs.id }} v${{ inputs.version }} is not available."
              fi
            )
            rm -rf "$pkg_temp"
          fi

          if curl -s "https://mods.bsquest.xyz/${{ inputs.game_version }}.json" | jq -r '. | to_entries | map(.key) | .[]' | grep -xq "${{ inputs.id }}"; then
            echo "run_build=false" >> $GITHUB_ENV
          fi
          true

      - name: Restore sccache cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.SCCACHE_DIR }}
          key: sccache-${{ runner.os }}-${{ inputs.id }}-
          restore-keys: |
            sccache-${{ runner.os }}-${{ inputs.id }}-

      - name: Get sccache cache hash
        if: env.run_build != 'false'
        id: sccache-hash-old
        run: |
          CACHE_BASE="sccache-${{ runner.os }}-${{ inputs.id }}-"
          echo "cache-base=$CACHE_BASE" >> $GITHUB_OUTPUT
          
          if [[ -d "${{ env.SCCACHE_DIR }}" ]]; then
            FILES=$(find "${{ env.SCCACHE_DIR }}" -type f ! -name stats -exec sha1sum {} \;)
            HASH=$(echo "$FILES" | sha1sum | awk '{print $1}')
            
            echo "hash=$HASH" >> $GITHUB_OUTPUT
            echo "cache-key=$CACHE_BASE$HASH" >> $GITHUB_OUTPUT
          fi
          cat $GITHUB_OUTPUT

      - name: Save current time
        id: sccache-time
        run: echo "timestamp=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Setup sccache
        if: env.run_build != 'false'
        env:
          DPKG_MAINTSCRIPT_PACKAGE_BLACKLIST: man-db
        run: |
          echo 'set man-db/auto-update false' | sudo debconf-communicate >/dev/null
          sudo dpkg-reconfigure man-db
          sudo apt update
          sudo apt install sccache

      - name: Prepend sccache launcher variables to CMakeLists.txt
        run: |
          if [ -f CMakeLists.txt ]; then
            echo "Processing list file..."
      
            # Read the original content of the 'list' file into a variable
            ORIGINAL_DATA=$(cat CMakeLists.txt)
      
            # Write the sccache lines to the 'list' file
            echo "set(CMAKE_C_COMPILER_LAUNCHER sccache)" > CMakeLists.txt
            echo "set(CMAKE_CXX_COMPILER_LAUNCHER sccache)" >> CMakeLists.txt
      
            # Append the original content back to the 'list' file
            echo "$ORIGINAL_DATA" >> CMakeLists.txt
      
            echo "Updated CMakeLists.txt file successfully."
          else
            echo "CMakeLists.txt file not found. Skipping..."
          fi

      - name: Cache Workspace
        if: env.run_build != 'false'
        id: cache-workspace
        uses: actions/cache@v4
        with:
          key: workspace-${{ runner.os }}-${{ inputs.id }}-${{ inputs.game_version }}-${{ inputs.version }}-${{ env.git_commit }}
          path: |
            ${{ github.workspace }}/${{ inputs.id }}

      - name: Extract Workspace
        working-directory: ${{ github.workspace }}
        if: env.run_build != 'false' && steps.cache-workspace.outputs.cache-hit == 'true'
        run: |
          mv "${{ inputs.id }}/workspace.txz" .
          rm -rf "${{ inputs.id }}"
          mkdir -p "${{ inputs.id }}"
          tar -xJvf workspace.txz -C "${{ inputs.id }}"
          rm workspace.txz

      - name: Resolve NDK
        if: env.run_build != 'false'
        run: |
          qpm ndk resolve -d || (
            echo "No NDK pinned."
            qpm ndk pin 27 || (
              qpm ndk download 27
              qpm ndk pin 27
            )
          )

      - name: Run pre-bump
        if: env.run_build != 'false' && inputs.prebump_command
        run: |
          ${{ inputs.prebump_command }}

      - name: Sort dependencies
        if: env.run_build != 'false'
        run: |
          # We don't need to sort dependencies, but this causes qpm to re-serialize qpm.json
          # and ensures that the file contains the additionalData object for each dependency.
          qpm dependency sort

      - name: Bump dependencies
        if: env.run_build != 'false'
        env:
          NEWEST_MODS: ${{ inputs.newest_mods }}
        run: |
          # Loop through each mod in newest_mods by newline, then split by colon
          echo "$NEWEST_MODS" | jq -rM '.[]' | while IFS=: read -r mod_name mod_version; do

            # Read qpm.json into a variable
            qpm_json=$(cat qpm.json)

            # Use jq to loop through .dependencies in qpm.json, check if .id matches mod_name, and update .versionRange

            if echo "$qpm_json" | jq -e ".dependencies[] | select(.id == \"$mod_name\")" > /dev/null; then
              echo "Updating $mod_name to version $mod_version"
              jq --arg mod_name "$mod_name" --arg mod_version "^${mod_version}" \
                '.dependencies[] |= if .id == $mod_name then .versionRange = $mod_version else . end' \
                qpm.json > qpm.json.tmp && mv qpm.json.tmp qpm.json
            fi
          done

      - name: Add qmodIncludeDirs
        if: env.run_build != 'false'
        run: |
          jq '.workspace.qmodIncludeDirs += ["extern/libs", "build"]' qpm.json > qpm.json.tmp && mv qpm.json.tmp qpm.json

      - name: Bump version
        if: env.run_build != 'false'
        run: |
          if [ "${{ inputs.version }}" != '' ]; then
            echo "Updating qpm.json with version ${{ inputs.version }}"
              jq --arg version "${{ inputs.version }}" \
                '.info.version = $version' qpm.json > qpm.json.tmp && mv qpm.json.tmp qpm.json
          fi

          if [ -e mod.template.json ]; then
            echo "Updating mod.template.json with game version ${{ inputs.game_version }}"
            jq --arg game_version "${{ inputs.game_version }}" \
              '.packageVersion = $game_version' mod.template.json > mod.template.json.tmp && mv mod.template.json.tmp mod.template.json
          fi

          if [ -e mod.json ]; then
            echo "Updating mod.json with game version ${{ inputs.game_version }}"
            jq --arg game_version "${{ inputs.game_version }}" \
              '.packageVersion = $game_version' mod.json > mod.json.tmp && mv mod.json.tmp mod.json
          fi

      - name: Include installed mods in qmod
        if: env.run_build != 'false'
        env:
          INSTALLED_MODS: ${{ inputs.installed_mods }}
        run: |
          temp_file="$(mktemp)"
          jq --argjson ids_to_update "$INSTALLED_MODS" \
            '.dependencies |= map(
              if .id | IN($ids_to_update[]) 
                then .additionalData.includeQmod = true
                else . 
              end
          )' qpm.json > "$temp_file" && mv "$temp_file" qpm.json

      - name: QPM restore
        if: env.run_build != 'false'
        run: |
          qpm restore --update

      - name: Display qpm.json
        if: env.run_build != 'false'
        continue-on-error: true
        run: |
          jq . qpm.json

      - name: Display qpm.shared.json
        if: env.run_build != 'false'
        continue-on-error: true
        run: |
          jq . qpm.shared.json

      - name: Build
        if: env.run_build != 'false' && steps.cache-workspace.outputs.cache-hit != 'true'
        run: |
          set -x
          ${{ inputs.build_command || 'qpm s build' }}
        env:
          HOME: ${{ env.HOME }}

      - name: List files
        if: env.run_build != 'false'
        run: |
          find

      - name: Create qmod
        if: env.run_build != 'false'
        run: |
          set -x
          ${{ inputs.qmod_command || 'qpm qmod zip --skip_build' }}
        env:
          HOME: ${{ env.HOME }}

      - name: Bump version
        if: env.run_build != 'false'
        run: |
          if [ "${{ inputs.version }}" != '' ]; then
            echo "Updating qpm.json with version ${{ inputs.version }}"
              jq --arg version "${{ inputs.version }}" \
                '.info.version = $version' qpm.json > qpm.json.tmp && mv qpm.json.tmp qpm.json
          fi

          if [ -e mod.template.json ]; then
            echo "Updating mod.template.json with game version ${{ inputs.game_version }}"
            jq --arg game_version "${{ inputs.game_version }}" \
              '.packageVersion = $game_version' mod.template.json > mod.template.json.tmp && mv mod.template.json.tmp mod.template.json
          fi

          if [ -e mod.json ]; then
            echo "Updating mod.json with game version ${{ inputs.game_version }}"
            jq --arg game_version "${{ inputs.game_version }}" \
              '.packageVersion = $game_version' mod.json > mod.json.tmp && mv mod.json.tmp mod.json
          fi
      
      - name: Unzip first qmod to temporary dir
        id: extract-qmod
        if: env.run_build != 'false' && inputs.install == true
        run: |
          work="$(mktemp -d)"
          qmod="$(find . -type f -name '*.qmod' | head -n 1)"
          
          if [[ ! -z "$qmod" ]]; then
            unzip -q "$qmod" -d "$work"
          fi
          
          echo "extracted=$work" >> $GITHUB_OUTPUT
          
          find . -name '*.qmod'

      - name: Upload unzipped qmod
        if: env.run_build != 'false' && inputs.install == true
        id: upload-qzip
        uses: actions/upload-artifact@v4
        with:
          name: qzip_${{ steps.qpm_id.outputs.id }}
          include-hidden-files: true
          path: |
            ${{ steps.extract-qmod.outputs.extracted }}/*
            
      - name: Update modLink
        if: env.run_build != 'false' && inputs.install == true
        env:
          link: https://nightly.link/${{ github.repository }}/actions/artifacts/${{ steps.upload-qzip.outputs.artifact-id }}.zip
        run: |
          temp_file="$(mktemp)"
          
          jq --arg link "$link" \
            '.info.additionalData = (.info.additionalData // {}) | .info.additionalData.modLink = $link' \
            qpm.json > "$temp_file" && mv "$temp_file" qpm.json

      - name: QPM restore
        if: env.run_build != 'false'
        run: |
          qpm restore --update

      - name: Install
        if: env.run_build != 'false' && inputs.install == true
        run: |
          qpm install

      - name: Display qpm.shared.json
        if: env.run_build != 'false'
        run: |
          cat qpm.shared.json

      - name: List QPM cache
        run: |
          qpm cache list || echo "No cache to list"

      - name: Stat all cache files
        if: env.run_build != 'false'
        run: |
          if [[ -d "${{ env.SCCACHE_DIR }}" ]]; then
            find "${{ env.SCCACHE_DIR }}" -type f -exec stat {} \;
          fi

      - name: Cleanup sccache entries
        if: env.run_build != 'false' && steps.cache-workspace.outputs.cache-hit != 'true'
        run: |
          echo "SCCACHE_START_TIME: ${{ steps.sccache-time.outputs.timestamp }}"
          [[ -d "${{ env.SCCACHE_DIR }}" ]] || exit 0
          find "${{ env.SCCACHE_DIR }}" -type f ! -newerat "@${{ steps.sccache-time.outputs.timestamp }}" -print -delete

      - name: Stat all cache files
        if: env.run_build != 'false'
        run: |
          [[ -d "${{ env.SCCACHE_DIR }}" ]] || exit 0
          find "${{ env.SCCACHE_DIR }}" -type f -exec stat {} \;

      - name: Get sccache cache hash
        if: env.run_build != 'false'
        id: sccache-hash
        run: |
          CACHE_BASE="sccache-${{ runner.os }}-${{ inputs.id }}-"
          echo "cache-base=$CACHE_BASE" >> $GITHUB_OUTPUT
          
          if [[ -d "${{ env.SCCACHE_DIR }}" ]]; then
            FILES=$(find "${{ env.SCCACHE_DIR }}" -type f ! -name stats -exec sha1sum {} \;)
            HASH=$(echo "$FILES" | sha1sum | awk '{print $1}')
            
            echo "hash=$HASH" >> $GITHUB_OUTPUT
            echo "cache-key=$CACHE_BASE$HASH" >> $GITHUB_OUTPUT
          fi
          cat $GITHUB_OUTPUT

      - name: Save sccache cache
        if: env.run_build != 'false' && steps.sccache-hash.outputs.cache-key != steps.sccache-hash-old.outputs.cache-key
        uses: actions/cache/save@v4
        with:
          path: ${{ env.SCCACHE_DIR }}
          key: ${{ steps.sccache-hash.outputs.cache-key }}

      - name: Delete all sccache cache entries except latest
        if: env.run_build != 'false'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh api -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/actions/caches \
            --paginate \
            -q '.actions_caches[] | select((.key | startswith("${{ steps.sccache-hash.outputs.cache-base }}")) and (.key != "${{ steps.sccache-hash.outputs.cache-key }}")) | .id' 2>&1 |
          while read cache_id; do
            echo "Deleting cache id $cache_id"
            gh api --method DELETE /repos/${{ github.repository }}/actions/caches/$cache_id
          done

      - name: Upload QPM Cache
        if: inputs.install == true
        uses: ./.github/actions/upload-qpm-cache
        with:
          artifact-name: ${{ steps.cache-name.outputs.cache-name }}

      - name: Upload Build
        if: env.run_build != 'false'
        uses: actions/upload-artifact@v4
        with:
          path: |
            ${{ inputs.id }}/*.qmod
          name: qmod_${{ steps.qpm_id.outputs.id }}

      - name: Cleanup Workspace
        if: env.run_build != 'false'
        run: |
          delete-if-exists() {
            if [[ -e "$1" ]]; then
              rm -rf "$1"
            fi
          }

          delete-if-exists "build/CMakeFiles"
          delete-if-exists "build/_deps"
          delete-if-exists "extern"
          delete-if-exists ".git"

      - name: Archive Workspace
        if: env.run_build != 'false'
        working-directory: ${{ github.workspace }}
        run: |
          tar -cJvf workspace.txz -C "${{ inputs.id }}" .
          rm -rf "${{ inputs.id }}"
          mkdir -p "${{ inputs.id }}"
          mv workspace.txz "${{ inputs.id }}/"

      - name: Upload Workspace
        if: env.run_build != 'false'
        uses: actions/upload-artifact@v4
        with:
          name: workspace_${{ steps.qpm_id.outputs.id }}
          include-hidden-files: true
          path: |
            ${{ inputs.id }}
            !${{ inputs.id }}/extern
